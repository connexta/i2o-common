/**
 * Copyright (c) Connexta
 *
 * <p>This is free software: you can redistribute it and/or modify it under the terms of the GNU
 * Lesser General Public License as published by the Free Software Foundation, either version 3 of
 * the License, or any later version.
 *
 * <p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
 * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details. A copy of the GNU Lesser General Public
 * License is distributed along with this program and can be found at
 * <http://www.gnu.org/licenses/lgpl.html>.
 */
package com.connexta.commons.queue.inmemory;

import com.connexta.commons.queue.ErrorCode;
import com.connexta.commons.queue.Queue.Id;
import com.connexta.commons.queue.QueueBroker;
import com.connexta.commons.queue.TaskInfo;
import com.connexta.commons.queue.impl.persistence.AbstractTaskPojo;
import com.google.common.annotations.VisibleForTesting;
import io.micrometer.core.instrument.MeterRegistry;
import io.micrometer.core.instrument.Tag;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.function.BiFunction;
import java.util.function.Function;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import org.apache.commons.lang3.StringUtils;

/**
 * Provides a non-persistent implementation for the queue broker that keeps queues and tasks in
 * memory.
 *
 * @param <E> the base exception class for all exceptions that can be thrown from this API
 * @param <C> the enumeration for all error codes specified by this API
 * @param <I> the base type of information associated with a task
 * @param <P> the base type of pojo used to persist tasks managed the queues
 * @param <O> the base type of all offering queues managed by this broker
 * @param <Q> the base type for all queues managed by this broker
 * @param <S> the base type for all composite queues managed by this broker
 * @param <T> the base type for all tasks managed by the queues
 */
public abstract class InMemoryQueueBroker<
        E extends Exception,
        C extends ErrorCode,
        I extends TaskInfo,
        P extends AbstractTaskPojo<P>,
        O extends InMemoryOfferingQueue<E, C, I, P, T>,
        Q extends InMemoryQueue<E, C, I, P, T>,
        S extends InMemoryCompositeQueue<E, C, I, P, O, T>,
        T extends InMemoryTask<E, C, I, P>>
    implements QueueBroker<E, C, I, O, Q, S, T> {
  /** Cache of all queues created so far keyed by the corresponding queue id. */
  private final Map<Id, O> queues = new ConcurrentHashMap<>();

  final Class<E> eclazz;
  final BiFunction<String, Throwable, ? extends E> iecreator;
  final Function<String, ? extends E> uvecreator;

  protected final String prefix;
  protected final Set<Tag> tags;
  protected final MeterRegistry meterRegistry;

  protected final int queueCapacity;

  /**
   * Instantiates a broker to manage queues with the specified maximum task capacity before a queue
   * starts blocking.
   *
   * @param eclazz the base exception class for all exceptions that can be thrown from this API
   * @param iecreator a function to instantiate an error (typically a subclass of <code>E</code>)
   *     when an invalid field is uncovered during serialization or deserialization. The function is
   *     called with a message and an optional cause for the error (might be <code>null</code> if no
   *     cause is available)
   * @param uvecreator a function to instantiate an unsupported version error during
   *     deserialization. The function is called with a message
   * @param queueCapacity the capacity for the queues this broker manages
   * @param prefix a prefix for the names of metric counters and gauges (e.g. transformation)
   * @param tags set of tags to use with all metrics generated by this broker and its managed queues
   * @param meterRegistry the micrometer registry to report metrics
   */
  @SuppressWarnings("squid:S00107" /* used as a base class */)
  public InMemoryQueueBroker(
      Class<E> eclazz,
      BiFunction<String, Throwable, ? extends E> iecreator,
      Function<String, ? extends E> uvecreator,
      int queueCapacity,
      String prefix,
      Stream<Tag> tags,
      MeterRegistry meterRegistry) {
    this.eclazz = eclazz;
    this.iecreator = iecreator;
    this.uvecreator = uvecreator;
    this.prefix = StringUtils.removeEnd(prefix, ".");
    this.tags = tags.collect(Collectors.toUnmodifiableSet());
    this.meterRegistry = meterRegistry;
    this.queueCapacity = queueCapacity;
  }

  @Override
  public O getQueue(Id id) {
    return getOfferingQueue(id);
  }

  @Override
  public S getQueue(Stream<Id> ids) {
    return createQueue(ids);
  }

  /**
   * Gets a processing queue given its identifier.
   *
   * <p>A new queue should be deployed if no queue currently exist for a given identifier.
   *
   * @param id the id for the queue to retrieve
   * @return the offering queue to use for the specified id
   * @throws IllegalArgumentException if this broker doesn't support queues for the specified class
   *     of task
   */
  public O getOfferingQueue(Id id) {
    return queues.computeIfAbsent(id, i -> createQueue(id));
  }

  /**
   * Gets an offering queue given its identifier if it is currently defined.
   *
   * @param id the id of the queue to retrieve
   * @return the queue to use for the specified class and id or empty if none already defined
   */
  @SuppressWarnings(
      "squid:S00119" /* 2-letter generic names limited to the method and ease readability */)
  public Optional<O> getQueueIfDefined(Id id) {
    return Optional.ofNullable(queues.get(id));
  }

  /**
   * Gets the number of queues currently managed by this broker.
   *
   * @return the number of queued managed by this broker
   */
  public int size() {
    return queues.size();
  }

  /**
   * Gets the capacity for the queues this broker manages.
   *
   * @return the capacity for the queues this broker manages
   */
  public int getQueueCapacity() {
    return queueCapacity;
  }

  /**
   * Gets a prefix for the names of metric counters and gauges (e.g. transformation).
   *
   * @return a prefix for the names of metric counters and gauges (e.g. transformation)
   */
  public String getMetricPrefix() {
    return prefix;
  }

  /**
   * Gets a set of tags to use with all metrics generated by this broker and its managed queues.
   *
   * @return a set of tags to use with all metrics generated by this broker and its managed queues
   */
  public Stream<Tag> metricTags() {
    return tags.stream();
  }

  /**
   * Gets the micrometer registry to report metrics.
   *
   * @return the micrometer registry to report metrics
   */
  public MeterRegistry getMeterRegistry() {
    return meterRegistry;
  }

  /** Clears all queues by removing all tasks currently defined in them. */
  public void clear() {
    queues.values().forEach(InMemoryQueue::clear);
  }

  /**
   * Called to create a new queue given its identifier.
   *
   * @param id the id for the new queue to create
   * @return a newly created queue for the specified id
   * @throws IllegalArgumentException if this broker doesn't support queues for the specified class
   *     of task
   */
  protected abstract O createQueue(Id id);

  /**
   * Called to create a new composite queue given a set of identifiers.
   *
   * @param ids the ids for the queues to compound together into one virtual queue
   * @return a newly created composite queue representing all specified queues
   * @throws IllegalArgumentException if this broker doesn't support queues for the specified class
   *     of task
   */
  protected abstract S createQueue(Stream<Id> ids);

  @VisibleForTesting
  void add(O queue) {
    queues.put(queue.getId(), queue);
  }
}
